/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * TEPID
 * The API for the TEPID Print server by the McGill Science Computer TaskForce. Tell us what we can do better on [github](https://github.com/ctf/tepid-server/).
 *
 * OpenAPI spec version: 1.02.00
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface About
 */
export interface About {
    /**
     * 
     * @type {boolean}
     * @memberof About
     */
    debug?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof About
     */
    ldapEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof About
     */
    startTimestamp?: number;
    /**
     * 
     * @type {string}
     * @memberof About
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof About
     */
    tag?: string;
    /**
     * 
     * @type {number}
     * @memberof About
     */
    creationTimestamp?: number;
    /**
     * 
     * @type {string}
     * @memberof About
     */
    creationTime?: string;
    /**
     * 
     * @type {string}
     * @memberof About
     */
    hash?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof About
     */
    warnings?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof About
     */
    uptime?: string;
}

/**
 * 
 * @export
 * @interface Destination
 */
export interface Destination {
    /**
     * 
     * @type {string}
     * @memberof Destination
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Destination
     */
    protocol?: string;
    /**
     * 
     * @type {string}
     * @memberof Destination
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof Destination
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof Destination
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof Destination
     */
    domain?: string;
    /**
     * 
     * @type {DestinationTicket}
     * @memberof Destination
     */
    ticket?: DestinationTicket;
    /**
     * 
     * @type {boolean}
     * @memberof Destination
     */
    up?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Destination
     */
    ppm?: number;
    /**
     * 
     * @type {string}
     * @memberof Destination
     */
    getId?: string;
}

/**
 * 
 * @export
 * @interface DestinationTicket
 */
export interface DestinationTicket {
    /**
     * 
     * @type {string}
     * @memberof DestinationTicket
     */
    getId?: string;
    /**
     * 
     * @type {string}
     * @memberof DestinationTicket
     */
    getRev?: string;
    /**
     * 
     * @type {string}
     * @memberof DestinationTicket
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof DestinationTicket
     */
    schema?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DestinationTicket
     */
    up?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DestinationTicket
     */
    reason?: string;
    /**
     * 
     * @type {User}
     * @memberof DestinationTicket
     */
    user?: User;
    /**
     * 
     * @type {number}
     * @memberof DestinationTicket
     */
    reported?: number;
}

/**
 * 
 * @export
 * @interface FullDestination
 */
export interface FullDestination {
    /**
     * 
     * @type {string}
     * @memberof FullDestination
     */
    getId?: string;
    /**
     * 
     * @type {string}
     * @memberof FullDestination
     */
    getRev?: string;
    /**
     * 
     * @type {string}
     * @memberof FullDestination
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof FullDestination
     */
    schema?: string;
    /**
     * 
     * @type {string}
     * @memberof FullDestination
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FullDestination
     */
    protocol?: string;
    /**
     * 
     * @type {string}
     * @memberof FullDestination
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof FullDestination
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof FullDestination
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof FullDestination
     */
    domain?: string;
    /**
     * 
     * @type {DestinationTicket}
     * @memberof FullDestination
     */
    ticket?: DestinationTicket;
    /**
     * 
     * @type {boolean}
     * @memberof FullDestination
     */
    up?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FullDestination
     */
    ppm?: number;
}

/**
 * 
 * @export
 * @interface MarqueeData
 */
export interface MarqueeData {
    /**
     * 
     * @type {string}
     * @memberof MarqueeData
     */
    getId?: string;
    /**
     * 
     * @type {string}
     * @memberof MarqueeData
     */
    getRev?: string;
    /**
     * 
     * @type {string}
     * @memberof MarqueeData
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof MarqueeData
     */
    schema?: string;
    /**
     * 
     * @type {string}
     * @memberof MarqueeData
     */
    title?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MarqueeData
     */
    entry?: Array<string>;
}

/**
 * 
 * @export
 * @interface PrintJob
 */
export interface PrintJob {
    /**
     * 
     * @type {string}
     * @memberof PrintJob
     */
    getId?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintJob
     */
    getRev?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintJob
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintJob
     */
    schema?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintJob
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintJob
     */
    queueName?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintJob
     */
    originalHost?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintJob
     */
    userIdentification?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintJob
     */
    destination?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintJob
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintJob
     */
    file?: string;
    /**
     * 
     * @type {number}
     * @memberof PrintJob
     */
    colorPages?: number;
    /**
     * 
     * @type {number}
     * @memberof PrintJob
     */
    pages?: number;
    /**
     * 
     * @type {number}
     * @memberof PrintJob
     */
    started?: number;
    /**
     * 
     * @type {number}
     * @memberof PrintJob
     */
    processed?: number;
    /**
     * 
     * @type {number}
     * @memberof PrintJob
     */
    printed?: number;
    /**
     * 
     * @type {number}
     * @memberof PrintJob
     */
    failed?: number;
    /**
     * 
     * @type {number}
     * @memberof PrintJob
     */
    received?: number;
    /**
     * 
     * @type {number}
     * @memberof PrintJob
     */
    eta?: number;
    /**
     * 
     * @type {number}
     * @memberof PrintJob
     */
    deleteDataOn?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PrintJob
     */
    refunded?: boolean;
}

/**
 * 
 * @export
 * @interface PrintQueue
 */
export interface PrintQueue {
    /**
     * 
     * @type {string}
     * @memberof PrintQueue
     */
    getId?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintQueue
     */
    getRev?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintQueue
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintQueue
     */
    schema?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintQueue
     */
    loadBalancer?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintQueue
     */
    defaultOn?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintQueue
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PrintQueue
     */
    destinations?: Array<string>;
}

/**
 * 
 * @export
 * @interface PutResponse
 */
export interface PutResponse {
    /**
     * 
     * @type {boolean}
     * @memberof PutResponse
     */
    ok?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PutResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PutResponse
     */
    rev?: string;
}

/**
 * 
 * @export
 * @interface QuotaData
 */
export interface QuotaData {
    /**
     * 
     * @type {number}
     * @memberof QuotaData
     */
    quota?: number;
    /**
     * 
     * @type {number}
     * @memberof QuotaData
     */
    maxQuota?: number;
    /**
     * 
     * @type {number}
     * @memberof QuotaData
     */
    totalPrinted?: number;
}

/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    _rev?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    schema?: string;
    /**
     * 
     * @type {User}
     * @memberof Session
     */
    user?: User;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    role?: string;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    expiration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    persistent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    valid?: boolean;
}

/**
 * 
 * @export
 * @interface SessionRequest
 */
export interface SessionRequest {
    /**
     * 
     * @type {string}
     * @memberof SessionRequest
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionRequest
     */
    password?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SessionRequest
     */
    persistent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SessionRequest
     */
    permanent?: boolean;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    givenName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    middleName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    shortUser?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    longUser?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    faculty?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    nick?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    realName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    salutation?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    preferredName?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    activeSince?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    studentId?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    jobExpiration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    colorPrinting?: boolean;
}


/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {FileList} [file]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addJobData(id: string, file?: FileList, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addJobData.');
            }
            const localVarPath = `/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"file" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(file || {}) : (file || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminConfigured(options: any = {}): FetchArgs {
            const localVarPath = `/users/configured`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        api(options: any = {}): FetchArgs {
            const localVarPath = `/about/api`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} dest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDestination(dest: string, options: any = {}): FetchArgs {
            // verify required parameter 'dest' is not null or undefined
            if (dest === null || dest === undefined) {
                throw new RequiredError('dest','Required parameter dest was null or undefined when calling deleteDestination.');
            }
            const localVarPath = `/destinations/{dest}`
                .replace(`{${"dest"}}`, encodeURIComponent(String(dest)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} queue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueue(queue: string, options: any = {}): FetchArgs {
            // verify required parameter 'queue' is not null or undefined
            if (queue === null || queue === undefined) {
                throw new RequiredError('queue','Required parameter queue was null or undefined when calling deleteQueue.');
            }
            const localVarPath = `/queues/{queue}`
                .replace(`{${"queue"}}`, encodeURIComponent(String(queue)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endCurrentSession(options: any = {}): FetchArgs {
            const localVarPath = `/sessions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endSession(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling endSession.');
            }
            const localVarPath = `/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceRefresh(sam: string, options: any = {}): FetchArgs {
            // verify required parameter 'sam' is not null or undefined
            if (sam === null || sam === undefined) {
                throw new RequiredError('sam','Required parameter sam was null or undefined when calling forceRefresh.');
            }
            const localVarPath = `/users/{sam}/refresh`
                .replace(`{${"sam"}}`, encodeURIComponent(String(sam)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbout(options: any = {}): FetchArgs {
            const localVarPath = `/about`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} queue 
         * @param {string} id 
         * @param {string} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(queue: string, id: string, file: string, options: any = {}): FetchArgs {
            // verify required parameter 'queue' is not null or undefined
            if (queue === null || queue === undefined) {
                throw new RequiredError('queue','Required parameter queue was null or undefined when calling getAttachment.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAttachment.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling getAttachment.');
            }
            const localVarPath = `/queues/{queue}/{id}/{file}`
                .replace(`{${"queue"}}`, encodeURIComponent(String(queue)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"file"}}`, encodeURIComponent(String(file)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinations(options: any = {}): FetchArgs {
            const localVarPath = `/destinations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinations1(options: any = {}): FetchArgs {
            const localVarPath = `/screensaver/destinations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getJob.');
            }
            const localVarPath = `/jobs/job/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} queue 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob1(queue: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'queue' is not null or undefined
            if (queue === null || queue === undefined) {
                throw new RequiredError('queue','Required parameter queue was null or undefined when calling getJob1.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getJob1.');
            }
            const localVarPath = `/queues/{queue}/{id}`
                .replace(`{${"queue"}}`, encodeURIComponent(String(queue)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoadBalancers(options: any = {}): FetchArgs {
            const localVarPath = `/queues/loadbalancers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarquee(options: any = {}): FetchArgs {
            const localVarPath = `/screensaver/marquee`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueues(options: any = {}): FetchArgs {
            const localVarPath = `/queues`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueues1(options: any = {}): FetchArgs {
            const localVarPath = `/screensaver/queues`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuota(sam: string, options: any = {}): FetchArgs {
            // verify required parameter 'sam' is not null or undefined
            if (sam === null || sam === undefined) {
                throw new RequiredError('sam','Required parameter sam was null or undefined when calling getQuota.');
            }
            const localVarPath = `/users/{sam}/quota`
                .replace(`{${"sam"}}`, encodeURIComponent(String(sam)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} user 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(user: string, token: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling getSession.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getSession.');
            }
            const localVarPath = `/sessions/{user}/{token}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options: any = {}): FetchArgs {
            const localVarPath = `/screensaver/queues/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(username: string, options: any = {}): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling getUserInfo.');
            }
            const localVarPath = `/screensaver/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateSessions(sam: string, options: any = {}): FetchArgs {
            // verify required parameter 'sam' is not null or undefined
            if (sam === null || sam === undefined) {
                throw new RequiredError('sam','Required parameter sam was null or undefined when calling invalidateSessions.');
            }
            const localVarPath = `/sessions/invalidate/{sam}`
                .replace(`{${"sam"}}`, encodeURIComponent(String(sam)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} like 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ldapAutoSuggest(like: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'like' is not null or undefined
            if (like === null || like === undefined) {
                throw new RequiredError('like','Required parameter like was null or undefined when calling ldapAutoSuggest.');
            }
            const localVarPath = `/users/autosuggest/{like}`
                .replace(`{${"like"}}`, encodeURIComponent(String(like)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(sam: string, options: any = {}): FetchArgs {
            // verify required parameter 'sam' is not null or undefined
            if (sam === null || sam === undefined) {
                throw new RequiredError('sam','Required parameter sam was null or undefined when calling listJobs.');
            }
            const localVarPath = `/jobs/{sam}`
                .replace(`{${"sam"}}`, encodeURIComponent(String(sam)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} queue 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs1(queue: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'queue' is not null or undefined
            if (queue === null || queue === undefined) {
                throw new RequiredError('queue','Required parameter queue was null or undefined when calling listJobs1.');
            }
            const localVarPath = `/queues/{queue}`
                .replace(`{${"queue"}}`, encodeURIComponent(String(queue)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} queue 
         * @param {number} [limit] 
         * @param {number} [from] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs2(queue: string, limit?: number, from?: number, options: any = {}): FetchArgs {
            // verify required parameter 'queue' is not null or undefined
            if (queue === null || queue === undefined) {
                throw new RequiredError('queue','Required parameter queue was null or undefined when calling listJobs2.');
            }
            const localVarPath = `/screensaver/queues/{queue}`
                .replace(`{${"queue"}}`, encodeURIComponent(String(queue)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PrintJob} [printJob] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newJob(printJob?: PrintJob, options: any = {}): FetchArgs {
            const localVarPath = `/jobs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PrintJob" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(printJob || {}) : (printJob || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: FullDestination; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDestinations(requestBody?: { [key: string]: FullDestination; }, options: any = {}): FetchArgs {
            const localVarPath = `/destinations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"{ [key: string]: FullDestination; }" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requestBody || {}) : (requestBody || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<PrintQueue>} [printQueue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueues(printQueue?: Array<PrintQueue>, options: any = {}): FetchArgs {
            const localVarPath = `/queues`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;PrintQueue&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(printQueue || {}) : (printQueue || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryLdap(sam: string, options: any = {}): FetchArgs {
            // verify required parameter 'sam' is not null or undefined
            if (sam === null || sam === undefined) {
                throw new RequiredError('sam','Required parameter sam was null or undefined when calling queryLdap.');
            }
            const localVarPath = `/users/{sam}`
                .replace(`{${"sam"}}`, encodeURIComponent(String(sam)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reprintJob(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling reprintJob.');
            }
            const localVarPath = `/jobs/job/{id}/reprint`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {boolean} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setColor(sam: string, body?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'sam' is not null or undefined
            if (sam === null || sam === undefined) {
                throw new RequiredError('sam','Required parameter sam was null or undefined when calling setColor.');
            }
            const localVarPath = `/users/{sam}/color`
                .replace(`{${"sam"}}`, encodeURIComponent(String(sam)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'text/plain';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {boolean} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExchange(sam: string, body?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'sam' is not null or undefined
            if (sam === null || sam === undefined) {
                throw new RequiredError('sam','Required parameter sam was null or undefined when calling setExchange.');
            }
            const localVarPath = `/users/{sam}/exchange`
                .replace(`{${"sam"}}`, encodeURIComponent(String(sam)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {number} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setJobExpiration(sam: string, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'sam' is not null or undefined
            if (sam === null || sam === undefined) {
                throw new RequiredError('sam','Required parameter sam was null or undefined when calling setJobExpiration.');
            }
            const localVarPath = `/users/{sam}/jobExpiration`
                .replace(`{${"sam"}}`, encodeURIComponent(String(sam)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setJobRefunded(id: string, body?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling setJobRefunded.');
            }
            const localVarPath = `/jobs/job/{id}/refunded`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNick(sam: string, body?: string, options: any = {}): FetchArgs {
            // verify required parameter 'sam' is not null or undefined
            if (sam === null || sam === undefined) {
                throw new RequiredError('sam','Required parameter sam was null or undefined when calling setNick.');
            }
            const localVarPath = `/users/{sam}/nick`
                .replace(`{${"sam"}}`, encodeURIComponent(String(sam)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} dest 
         * @param {DestinationTicket} [destinationTicket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStatus(dest: string, destinationTicket?: DestinationTicket, options: any = {}): FetchArgs {
            // verify required parameter 'dest' is not null or undefined
            if (dest === null || dest === undefined) {
                throw new RequiredError('dest','Required parameter dest was null or undefined when calling setStatus.');
            }
            const localVarPath = `/destinations/{dest}`
                .replace(`{${"dest"}}`, encodeURIComponent(String(dest)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DestinationTicket" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(destinationTicket || {}) : (destinationTicket || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SessionRequest} [sessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startSession(sessionRequest?: SessionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/sessions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SessionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(sessionRequest || {}) : (sessionRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {FileList} [file]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addJobData(id: string, file?: FileList, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PutResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).addJobData(id, file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminConfigured(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).adminConfigured(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        api(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).api(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} dest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDestination(dest: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).deleteDestination(dest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} queue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueue(queue: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).deleteQueue(queue, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endCurrentSession(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).endCurrentSession(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endSession(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).endSession(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceRefresh(sam: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).forceRefresh(sam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<About> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getAbout(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} queue 
         * @param {string} id 
         * @param {string} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(queue: string, id: string, file: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getAttachment(queue, id, file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinations(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: Destination; }> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getDestinations(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinations1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: Destination; }> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getDestinations1(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PrintJob> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getJob(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} queue 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob1(queue: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PrintJob> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getJob1(queue, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoadBalancers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getLoadBalancers(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarquee(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MarqueeData>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getMarquee(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueues(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PrintQueue>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getQueues(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueues1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PrintQueue>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getQueues1(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuota(sam: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuotaData> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getQuota(sam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} user 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(user: string, token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getSession(user, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: boolean; }> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getStatus(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getUserInfo(username, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateSessions(sam: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).invalidateSessions(sam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} like 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ldapAutoSuggest(like: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).ldapAutoSuggest(like, limit, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(sam: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PrintJob>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).listJobs(sam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} queue 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs1(queue: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PrintJob>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).listJobs1(queue, limit, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} queue 
         * @param {number} [limit] 
         * @param {number} [from] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs2(queue: string, limit?: number, from?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PrintJob>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).listJobs2(queue, limit, from, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {PrintJob} [printJob] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newJob(printJob?: PrintJob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).newJob(printJob, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {{ [key: string]: FullDestination; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDestinations(requestBody?: { [key: string]: FullDestination; }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).putDestinations(requestBody, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {Array<PrintQueue>} [printQueue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueues(printQueue?: Array<PrintQueue>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).putQueues(printQueue, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryLdap(sam: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).queryLdap(sam, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reprintJob(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).reprintJob(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {boolean} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setColor(sam: string, body?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).setColor(sam, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {boolean} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExchange(sam: string, body?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).setExchange(sam, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {number} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setJobExpiration(sam: string, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).setJobExpiration(sam, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setJobRefunded(id: string, body?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PutResponse> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).setJobRefunded(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} sam 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNick(sam: string, body?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).setNick(sam, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} dest 
         * @param {DestinationTicket} [destinationTicket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStatus(dest: string, destinationTicket?: DestinationTicket, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).setStatus(dest, destinationTicket, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SessionRequest} [sessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startSession(sessionRequest?: SessionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).startSession(sessionRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {FileList} [file]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addJobData(id: string, file?: FileList, options?: any) {
            return DefaultApiFp(configuration).addJobData(id, file, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminConfigured(options?: any) {
            return DefaultApiFp(configuration).adminConfigured(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        api(options?: any) {
            return DefaultApiFp(configuration).api(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} dest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDestination(dest: string, options?: any) {
            return DefaultApiFp(configuration).deleteDestination(dest, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} queue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueue(queue: string, options?: any) {
            return DefaultApiFp(configuration).deleteQueue(queue, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endCurrentSession(options?: any) {
            return DefaultApiFp(configuration).endCurrentSession(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endSession(id: string, options?: any) {
            return DefaultApiFp(configuration).endSession(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} sam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceRefresh(sam: string, options?: any) {
            return DefaultApiFp(configuration).forceRefresh(sam, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbout(options?: any) {
            return DefaultApiFp(configuration).getAbout(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} queue 
         * @param {string} id 
         * @param {string} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(queue: string, id: string, file: string, options?: any) {
            return DefaultApiFp(configuration).getAttachment(queue, id, file, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinations(options?: any) {
            return DefaultApiFp(configuration).getDestinations(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinations1(options?: any) {
            return DefaultApiFp(configuration).getDestinations1(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(id: string, options?: any) {
            return DefaultApiFp(configuration).getJob(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} queue 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob1(queue: string, id: string, options?: any) {
            return DefaultApiFp(configuration).getJob1(queue, id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoadBalancers(options?: any) {
            return DefaultApiFp(configuration).getLoadBalancers(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarquee(options?: any) {
            return DefaultApiFp(configuration).getMarquee(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueues(options?: any) {
            return DefaultApiFp(configuration).getQueues(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueues1(options?: any) {
            return DefaultApiFp(configuration).getQueues1(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} sam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuota(sam: string, options?: any) {
            return DefaultApiFp(configuration).getQuota(sam, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} user 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(user: string, token: string, options?: any) {
            return DefaultApiFp(configuration).getSession(user, token, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any) {
            return DefaultApiFp(configuration).getStatus(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(username: string, options?: any) {
            return DefaultApiFp(configuration).getUserInfo(username, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} sam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateSessions(sam: string, options?: any) {
            return DefaultApiFp(configuration).invalidateSessions(sam, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} like 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ldapAutoSuggest(like: string, limit?: number, options?: any) {
            return DefaultApiFp(configuration).ldapAutoSuggest(like, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} sam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs(sam: string, options?: any) {
            return DefaultApiFp(configuration).listJobs(sam, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} queue 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs1(queue: string, limit?: number, options?: any) {
            return DefaultApiFp(configuration).listJobs1(queue, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} queue 
         * @param {number} [limit] 
         * @param {number} [from] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobs2(queue: string, limit?: number, from?: number, options?: any) {
            return DefaultApiFp(configuration).listJobs2(queue, limit, from, options)(fetch, basePath);
        },
        /**
         * 
         * @param {PrintJob} [printJob] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newJob(printJob?: PrintJob, options?: any) {
            return DefaultApiFp(configuration).newJob(printJob, options)(fetch, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: FullDestination; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDestinations(requestBody?: { [key: string]: FullDestination; }, options?: any) {
            return DefaultApiFp(configuration).putDestinations(requestBody, options)(fetch, basePath);
        },
        /**
         * 
         * @param {Array<PrintQueue>} [printQueue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueues(printQueue?: Array<PrintQueue>, options?: any) {
            return DefaultApiFp(configuration).putQueues(printQueue, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} sam 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryLdap(sam: string, options?: any) {
            return DefaultApiFp(configuration).queryLdap(sam, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reprintJob(id: string, options?: any) {
            return DefaultApiFp(configuration).reprintJob(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} sam 
         * @param {boolean} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setColor(sam: string, body?: boolean, options?: any) {
            return DefaultApiFp(configuration).setColor(sam, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} sam 
         * @param {boolean} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExchange(sam: string, body?: boolean, options?: any) {
            return DefaultApiFp(configuration).setExchange(sam, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} sam 
         * @param {number} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setJobExpiration(sam: string, body?: number, options?: any) {
            return DefaultApiFp(configuration).setJobExpiration(sam, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setJobRefunded(id: string, body?: boolean, options?: any) {
            return DefaultApiFp(configuration).setJobRefunded(id, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} sam 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNick(sam: string, body?: string, options?: any) {
            return DefaultApiFp(configuration).setNick(sam, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} dest 
         * @param {DestinationTicket} [destinationTicket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStatus(dest: string, destinationTicket?: DestinationTicket, options?: any) {
            return DefaultApiFp(configuration).setStatus(dest, destinationTicket, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SessionRequest} [sessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startSession(sessionRequest?: SessionRequest, options?: any) {
            return DefaultApiFp(configuration).startSession(sessionRequest, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {FileList} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addJobData(id: string, file?: FileList, options?: any) {
        return DefaultApiFp(this.configuration).addJobData(id, file, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public adminConfigured(options?: any) {
        return DefaultApiFp(this.configuration).adminConfigured(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public api(options?: any) {
        return DefaultApiFp(this.configuration).api(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} dest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteDestination(dest: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteDestination(dest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} queue 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteQueue(queue: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteQueue(queue, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public endCurrentSession(options?: any) {
        return DefaultApiFp(this.configuration).endCurrentSession(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public endSession(id: string, options?: any) {
        return DefaultApiFp(this.configuration).endSession(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} sam 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public forceRefresh(sam: string, options?: any) {
        return DefaultApiFp(this.configuration).forceRefresh(sam, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAbout(options?: any) {
        return DefaultApiFp(this.configuration).getAbout(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} queue 
     * @param {string} id 
     * @param {string} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAttachment(queue: string, id: string, file: string, options?: any) {
        return DefaultApiFp(this.configuration).getAttachment(queue, id, file, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDestinations(options?: any) {
        return DefaultApiFp(this.configuration).getDestinations(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDestinations1(options?: any) {
        return DefaultApiFp(this.configuration).getDestinations1(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getJob(id: string, options?: any) {
        return DefaultApiFp(this.configuration).getJob(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} queue 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getJob1(queue: string, id: string, options?: any) {
        return DefaultApiFp(this.configuration).getJob1(queue, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLoadBalancers(options?: any) {
        return DefaultApiFp(this.configuration).getLoadBalancers(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMarquee(options?: any) {
        return DefaultApiFp(this.configuration).getMarquee(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getQueues(options?: any) {
        return DefaultApiFp(this.configuration).getQueues(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getQueues1(options?: any) {
        return DefaultApiFp(this.configuration).getQueues1(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} sam 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getQuota(sam: string, options?: any) {
        return DefaultApiFp(this.configuration).getQuota(sam, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} user 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSession(user: string, token: string, options?: any) {
        return DefaultApiFp(this.configuration).getSession(user, token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStatus(options?: any) {
        return DefaultApiFp(this.configuration).getStatus(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserInfo(username: string, options?: any) {
        return DefaultApiFp(this.configuration).getUserInfo(username, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} sam 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public invalidateSessions(sam: string, options?: any) {
        return DefaultApiFp(this.configuration).invalidateSessions(sam, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} like 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public ldapAutoSuggest(like: string, limit?: number, options?: any) {
        return DefaultApiFp(this.configuration).ldapAutoSuggest(like, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} sam 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listJobs(sam: string, options?: any) {
        return DefaultApiFp(this.configuration).listJobs(sam, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} queue 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listJobs1(queue: string, limit?: number, options?: any) {
        return DefaultApiFp(this.configuration).listJobs1(queue, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} queue 
     * @param {number} [limit] 
     * @param {number} [from] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listJobs2(queue: string, limit?: number, from?: number, options?: any) {
        return DefaultApiFp(this.configuration).listJobs2(queue, limit, from, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {PrintJob} [printJob] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public newJob(printJob?: PrintJob, options?: any) {
        return DefaultApiFp(this.configuration).newJob(printJob, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: FullDestination; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putDestinations(requestBody?: { [key: string]: FullDestination; }, options?: any) {
        return DefaultApiFp(this.configuration).putDestinations(requestBody, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {Array<PrintQueue>} [printQueue] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public putQueues(printQueue?: Array<PrintQueue>, options?: any) {
        return DefaultApiFp(this.configuration).putQueues(printQueue, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} sam 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public queryLdap(sam: string, options?: any) {
        return DefaultApiFp(this.configuration).queryLdap(sam, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public reprintJob(id: string, options?: any) {
        return DefaultApiFp(this.configuration).reprintJob(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} sam 
     * @param {boolean} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setColor(sam: string, body?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).setColor(sam, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} sam 
     * @param {boolean} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setExchange(sam: string, body?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).setExchange(sam, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} sam 
     * @param {number} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setJobExpiration(sam: string, body?: number, options?: any) {
        return DefaultApiFp(this.configuration).setJobExpiration(sam, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {boolean} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setJobRefunded(id: string, body?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).setJobRefunded(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} sam 
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setNick(sam: string, body?: string, options?: any) {
        return DefaultApiFp(this.configuration).setNick(sam, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} dest 
     * @param {DestinationTicket} [destinationTicket] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setStatus(dest: string, destinationTicket?: DestinationTicket, options?: any) {
        return DefaultApiFp(this.configuration).setStatus(dest, destinationTicket, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SessionRequest} [sessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public startSession(sessionRequest?: SessionRequest, options?: any) {
        return DefaultApiFp(this.configuration).startSession(sessionRequest, options)(this.fetch, this.basePath);
    }

}

